Конечно. Вот 6 тест-кейсов для вашей системы, оформленные в виде единой таблицы. Я сохранил ваши 4 кейса и добавил 2
новых для проверки обработки ошибок и целостности данных.

### Тест-кейсы для MiniToolStream

| ID        | Название                                            | Цель                                                                                                                       | Предусловия                                                                           | Шаги выполнения                                                                                                                                                                                                                                                                                                                     | Ожидаемый результат                                                                                                                                                                                                                          |
|:----------|:----------------------------------------------------|:---------------------------------------------------------------------------------------------------------------------------|:--------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **TC-01** | **Базовый сценарий: Публикация и чтение**           | Проверить основной "счастливый путь": успешная публикация и последующее чтение.                                            | - Канал (topic) `orders` существует и пуст.<br>- Продюсер и потребитель авторизованы. | 1. **Продюсер** вызывает `IngressService.Publish`:<br>   - `topic`: "orders"<br>   - `data`: `{"order_id": 123}`<br>   - `headers`: `{"source": "web-api", "content-type": "application/json"}`<br>2. **Потребитель** вызывает `EgressService.Fetch`:<br>   - `topic`: "orders"<br>   - `start_sequence`: 1<br>   - `batch_size`: 1 | 1. `Publish` возвращает `PublishResponse` с `StatusCode` успеха и `sequence = 1`.<br>2. `Fetch` возвращает стрим с **одним** сообщением.<br>3. Поля сообщения соответствуют отправленным (`sequence`, `data`, `headers`).                    |
| **TC-02** | **Пакетное чтение сообщений (Batch Fetch)**         | Проверить, что потребитель может за один запрос получить несколько сообщений и что поле `timestamp` корректно установлено. | - В канале `logs` есть 3 сообщения (`sequence` 1, 2, 3).                              | 1. **Потребитель** вызывает `EgressService.Fetch`:<br>   - `topic`: "logs"<br>   - `start_sequence`: 2<br>   - `batch_size`: 2                                                                                                                                                                                                      | 1. `Fetch` возвращает стрим с **двумя** сообщениями.<br>2. Первое сообщение имеет `sequence = 2`.<br>3. Второе сообщение имеет `sequence = 3`.<br>4. У обоих сообщений поле `timestamp` заполнено и является корректной временной меткой.    |
| **TC-03** | **Чтение с "конца" потока и получение уведомлений** | Проверить связку `GetLastSequence` и `Subscribe` для чтения только новых сообщений.                                        | - В канале `events` 50 сообщений (последний `sequence` = 50).                         | 1. **Потребитель** вызывает `GetLastSequence` для топика `events`.<br>2. **Потребитель** вызывает `Subscribe`, передав в `start_sequence` результат из шага 1 + 1 (т.е. 51).<br>3. **Продюсер** публикует новое сообщение в `events`.                                                                                               | 1. `GetLastSequence` возвращает `last_sequence = 50`.<br>2. `Subscribe` устанавливает соединение без отправки уведомлений.<br>3. После публикации потребитель получает `Notification` с `sequence = 51`.                                     |
| **TC-04** | **Независимость потребителей**                      | Проверить, что два потребителя читают один канал, не влияя друг на друга.                                                  | - В канале `metrics` есть одно сообщение (M1) с `sequence = 1`.                       | 1. **Потребитель А** читает `topic="metrics"`, `start_sequence=1`.<br>2. **Продюсер** публикует новое сообщение (M2).<br>3. **Потребитель Б** читает `topic="metrics"`, `start_sequence=1`, `batch_size=2`.<br>4. **Потребитель А** читает `topic="metrics"`, `start_sequence=2`.                                                   | 1. **Потребитель А** (шаг 1) получает M1.<br>2. **Потребитель Б** (шаг 3) получает M1 и M2.<br>3. **Потребитель А** (шаг 4) получает M2.<br>*Чтение Потребителем Б не помешало Потребителю А.*                                               |
| **TC-05** | **Ошибка: Публикация в несуществующий топик**       | Проверить, что система корректно обрабатывает попытку публикации в канал, который не существует.                           | - Канала (топика) с именем `non-existent-topic` не существует в системе.              | 1. **Продюсер** вызывает `IngressService.Publish` с параметрами:<br>   - `topic`: "non-existent-topic"<br>   - `data`: `{"key": "value"}`                                                                                                                                                                                           | 1. Вызов `Publish` возвращает `PublishResponse` с `StatusCode`, указывающим на ошибку (например, `404` или `NotFound`).<br>2. Поле `ResponderError` содержит человекочитаемое описание ошибки ("topic not found").<br>3. `sequence` равен 0. |
| **TC-06** | **Целостность бинарных данных и пустых полей**      | Проверить, что система корректно передает бинарные данные без искажений и обрабатывает сообщения с пустыми полями.         | - Канал `media` существует.                                                           | 1. **Продюсер** публикует сообщение с бинарными данными (например, картинка 1x1 pixel) и **без заголовков (`headers`)**.<br>2. **Потребитель** вычитывает это сообщение по его `sequence`.                                                                                                                                          | 1. Поле `data` у потребителя побайтово совпадает с оригинальной картинкой.<br>2. Поле `headers` у полученного сообщения является пустым (но не `null`), что соответствует отправленному.                                                     |