# ГЛАВА 3. РЕАЛИЗАЦИЯ

В данной главе представлена детальная реализация всех компонентов системы MiniToolStream. Описание каждого модуля включает архитектурные решения, фрагменты исходного кода с подробными комментариями, а также обоснование выбранных технических подходов. Реализация выполнена на языке программирования Go с использованием современных практик разработки распределенных систем.

## 3.1 Реализация точки входа (Ingress Service)

Ingress Service представляет собой критически важный компонент системы, отвечающий за прием сообщений от клиентов и их надежное сохранение в гибридном хранилище. Этот сервис является первой точкой контакта для всех издателей сообщений и должен обеспечивать высокую производительность, надежность и безопасность операций.

### 3.1.1 Архитектура и структура сервиса

При проектировании Ingress Service был применен принцип Clean Architecture (чистая архитектура), предложенный Робертом Мартином. Данный подход обеспечивает четкое разделение ответственности между компонентами, упрощает тестирование и позволяет легко модифицировать отдельные части системы без влияния на другие модули.

Структура сервиса организована следующим образом:

- **cmd/server/main.go** - точка входа приложения, содержит логику инициализации всех компонентов, настройку зависимостей и запуск gRPC сервера
- **internal/delivery/grpc** - слой представления (gRPC handlers), обрабатывает входящие запросы от клиентов, выполняет их валидацию и маршрутизацию к соответствующим use cases
- **internal/usecase** - слой бизнес-логики, содержит основные алгоритмы обработки сообщений, включая критическую логику предотвращения race conditions
- **internal/repository** - слой работы с данными, обеспечивает абстракцию над конкретными хранилищами (Tarantool для метаданных, MinIO для полезной нагрузки)
- **internal/config** - управление конфигурацией приложения и интеграция с HashiCorp Vault для безопасного хранения учетных данных
- **pkg/logger** - инфраструктурный слой логирования, предоставляет структурированное логирование для мониторинга и отладки

Такая многоуровневая архитектура позволяет изолировать бизнес-логику от деталей реализации транспортного уровня и хранилищ данных. Это критически важно для поддерживаемости кода и возможности его эволюции без значительных переработок.

### 3.1.2 Инициализация сервиса

Процесс инициализации Ingress Service является критическим этапом, определяющим корректность работы всей системы. Инициализация выполняется в строго определенном порядке, что обеспечивает правильную настройку всех зависимостей и компонентов перед началом обработки запросов.

Точка входа приложения (`cmd/server/main.go:33-217`) выполняет следующую последовательность инициализации:

```go
// 1. Загрузка конфигурации
cfg, err := config.Load(*configPath)
if err != nil {
    log.Fatalf("Failed to load configuration: %v", err)
}

// 2. Инициализация логгера
appLogger, err := logger.New(logger.Config{
    Level:      cfg.Logger.Level,
    Format:     cfg.Logger.Format,
    OutputPath: cfg.Logger.OutputPath,
})
```

На первом этапе происходит загрузка конфигурации приложения. Система поддерживает два источника конфигурации: YAML-файл и переменные окружения. Это обеспечивает гибкость развертывания в различных средах - от локальной разработки до production-окружения в Kubernetes. Приоритет отдается переменным окружения, что соответствует принципам 12-factor app и позволяет безопасно переопределять параметры без изменения конфигурационных файлов.

Сразу после загрузки конфигурации инициализируется структурированный логгер. Использование структурированного логирования (structured logging) критически важно для последующего анализа поведения системы в production. Каждая запись в логе содержит не только текстовое сообщение, но и типизированные поля (subject, sequence, client_id и т.д.), что существенно упрощает поиск и анализ проблем через системы агрегации логов (например, ELK stack или Grafana Loki).

### 3.1.3 Интеграция с HashiCorp Vault

Одним из ключевых требований к современным распределенным системам является безопасное управление конфиденциальной информацией, такой как пароли баз данных, ключи доступа к объектным хранилищам и криптографические ключи. Хранение таких данных непосредственно в конфигурационных файлах или переменных окружения создает серьезные риски безопасности, особенно в контексте систем контроля версий и CI/CD pipeline.

Для решения этой проблемы в системе MiniToolStream реализована интеграция с HashiCorp Vault - индустриальным стандартом для управления секретами. Vault обеспечивает централизованное хранение, динамическую генерацию и автоматическую ротацию секретов, а также детальное логирование всех операций доступа к конфиденциальным данным.

После инициализации базовых компонентов, сервис подключается к Vault для получения секретов (`cmd/server/main.go:65-79`):

```go
vaultClient, err := config.NewVaultClient(&cfg.Vault)
if err != nil {
    appLogger.Fatal("Failed to create Vault client", logger.Error(err))
}

// Применение секретов из Vault к конфигурации
if vaultClient != nil {
    appLogger.Info("Loading secrets from Vault")
    if err := config.ApplyVaultSecrets(ctx, cfg, vaultClient); err != nil {
        appLogger.Fatal("Failed to apply Vault secrets", logger.Error(err))
    }
}
```

Важно отметить, что интеграция с Vault является опциональной (контролируется флагом `cfg.Vault.Enabled`). Это позволяет упростить локальную разработку и тестирование, когда развертывание полноценной инфраструктуры Vault может быть избыточным. В production-окружении использование Vault является обязательным требованием безопасности.

Реализация клиента Vault (`internal/config/vault.go:17-46`) создает подключение с поддержкой KV v2 secrets engine:

```go
func NewVaultClient(cfg *VaultConfig) (*VaultClient, error) {
    if !cfg.Enabled {
        return nil, nil // Vault отключен
    }

    vaultCfg := vault.DefaultConfig()
    vaultCfg.Address = cfg.Address

    client, err := vault.NewClient(vaultCfg)
    if err != nil {
        return nil, fmt.Errorf("failed to create vault client: %w", err)
    }

    // Установка токена
    token, err := cfg.GetVaultToken()
    if err != nil {
        return nil, err
    }
    client.SetToken(token)

    // Установка namespace при необходимости
    if cfg.Namespace != "" {
        client.SetNamespace(cfg.Namespace)
    }

    return &VaultClient{
        client: client,
        config: cfg,
    }, nil
}
```

Метод `ApplyVaultSecrets` (`internal/config/vault.go:74-111`) загружает учетные данные для Tarantool и MinIO:

```go
func ApplyVaultSecrets(ctx context.Context, cfg *Config, vaultClient *VaultClient) error {
    // Загрузка учетных данных Tarantool
    if cfg.Tarantool.VaultPath != "" {
        secret, err := vaultClient.GetSecret(ctx, cfg.Tarantool.VaultPath)
        if err != nil {
            return fmt.Errorf("failed to get tarantool secrets: %w", err)
        }

        if user, ok := secret["user"].(string); ok {
            cfg.Tarantool.User = user
        }
        if password, ok := secret["password"].(string); ok {
            cfg.Tarantool.Password = password
        }
    }

    // Загрузка учетных данных MinIO
    if cfg.MinIO.VaultPath != "" {
        secret, err := vaultClient.GetSecret(ctx, cfg.MinIO.VaultPath)
        if err != nil {
            return fmt.Errorf("failed to get minio secrets: %w", err)
        }

        if accessKey, ok := secret["access_key_id"].(string); ok {
            cfg.MinIO.AccessKeyID = accessKey
        }
        if secretKey, ok := secret["secret_access_key"].(string); ok {
            cfg.MinIO.SecretAccessKey = secretKey
        }
    }

    return nil
}
```

### 3.1.4 Подключение к Tarantool

Сервис устанавливает соединение с Tarantool для хранения метаданных сообщений (`internal/repository/tarantool/client.go:33-66`):

```go
func NewRepository(config *Config, log *logger.Logger) (*Repository, error) {
    ctx := context.Background()

    // Создание dialer для Tarantool
    dialer := tarantool.NetDialer{
        Address:  config.Address,
        User:     config.User,
        Password: config.Password,
    }

    // Опции подключения
    opts := tarantool.Opts{
        Timeout: config.Timeout,
    }

    // Подключение к Tarantool
    conn, err := tarantool.Connect(ctx, dialer, opts)
    if err != nil {
        return nil, fmt.Errorf("failed to connect to Tarantool: %w", err)
    }

    repo := &Repository{
        conn:   conn,
        config: config,
        logger: log,
        closed: false,
    }

    return repo, nil
}
```

Репозиторий предоставляет методы для работы с последовательностями и сообщениями:

**Получение следующего sequence number** (`internal/repository/tarantool/client.go:114-137`):

```go
func (r *Repository) GetNextSequence() (uint64, error) {
    r.logger.Debug("Getting next sequence from Tarantool")

    resp, err := r.call("get_next_sequence", []interface{}{})
    if err != nil {
        r.logger.Error("Failed to get next sequence from Tarantool",
            logger.Error(err),
        )
        return 0, fmt.Errorf("failed to get next sequence: %w", err)
    }

    if len(resp) == 0 {
        return 0, fmt.Errorf("empty response from Tarantool")
    }

    sequence := toUint64(resp[0])

    r.logger.Debug("Got sequence from Tarantool",
        logger.Uint64("sequence", sequence),
    )

    return sequence, nil
}
```

**Вставка метаданных сообщения** (`internal/repository/tarantool/client.go:139-181`):

```go
func (r *Repository) InsertMessage(sequence uint64, subject string, headers map[string]string, objectName string) error {
    if subject == "" {
        return fmt.Errorf("subject cannot be empty")
    }

    if headers == nil {
        headers = make(map[string]string)
    }

    r.logger.Debug("Inserting message to Tarantool",
        logger.Uint64("sequence", sequence),
        logger.String("subject", subject),
        logger.String("object_name", objectName),
    )

    // Вызов функции Tarantool
    resp, err := r.call("insert_message", []interface{}{
        sequence,
        subject,
        headers,
        objectName,
    })
    if err != nil {
        r.logger.Error("Failed to insert message to Tarantool",
            logger.String("subject", subject),
            logger.Uint64("sequence", sequence),
            logger.Error(err),
        )
        return fmt.Errorf("failed to insert message: %w", err)
    }

    if len(resp) == 0 {
        return fmt.Errorf("empty response from Tarantool")
    }

    r.logger.Debug("Message inserted successfully",
        logger.String("subject", subject),
        logger.Uint64("sequence", sequence),
    )

    return nil
}
```

### 3.1.5 Подключение к MinIO

Для хранения полезной нагрузки используется MinIO (`internal/repository/minio/client.go:37-59`):

```go
func NewRepository(config *Config, log *logger.Logger) (*Repository, error) {
    if config == nil {
        return nil, fmt.Errorf("config cannot be nil")
    }

    // Инициализация клиента MinIO
    minioClient, err := minio.New(config.Endpoint, &minio.Options{
        Creds:  credentials.NewStaticV4(config.AccessKeyID, config.SecretAccessKey, ""),
        Secure: config.UseSSL,
    })
    if err != nil {
        return nil, fmt.Errorf("failed to create MinIO client: %w", err)
    }

    repo := &Repository{
        client:      minioClient,
        config:      config,
        logger:      log,
        bucketCache: make(map[string]bool),
    }

    return repo, nil
}
```

**Загрузка данных в MinIO** (`internal/repository/minio/client.go:120-161`):

```go
func (r *Repository) UploadData(ctx context.Context, objectName string, data []byte, contentType string) error {
    if len(data) == 0 {
        // Нет данных для загрузки
        return nil
    }

    bucketName := r.config.BucketName

    r.logger.Debug("Uploading data to MinIO",
        logger.String("bucket", bucketName),
        logger.String("object", objectName),
        logger.Int("size", len(data)),
        logger.String("content_type", contentType),
    )

    // Проверка существования bucket
    if err := r.EnsureBucket(ctx); err != nil {
        return err
    }

    // Загрузка объекта
    reader := bytes.NewReader(data)
    _, err := r.client.PutObject(ctx, bucketName, objectName, reader, int64(len(data)), minio.PutObjectOptions{
        ContentType: contentType,
    })
    if err != nil {
        r.logger.Error("Failed to upload object to MinIO",
            logger.String("bucket", bucketName),
            logger.String("object", objectName),
            logger.Error(err),
        )
        return fmt.Errorf("failed to upload object: %w", err)
    }

    r.logger.Debug("Data uploaded successfully",
        logger.String("bucket", bucketName),
        logger.String("object", objectName),
    )

    return nil
}
```

### 3.1.6 Реализация бизнес-логики публикации

Бизнес-логика публикации сообщений представляет собой наиболее критичный компонент Ingress Service, требующий особого внимания к корректности и надежности реализации. Основная сложность заключается в координации операций с двумя независимыми хранилищами (Tarantool и MinIO) при отсутствии распределенных транзакций.

**Проблема race condition в распределенных системах**

При работе с гибридным хранилищем возникает фундаментальная проблема: необходимо обеспечить, чтобы подписчики никогда не получили уведомление о сообщении, данные которого еще не доступны в MinIO. Если сначала записать метаданные в Tarantool, а затем загрузить payload в MinIO, то в промежутке между этими операциями подписчик может прочитать метаданные и попытаться получить данные из MinIO, которых там еще нет. Это приведет к ошибке и нарушению гарантий доставки сообщений.

Обратный порядок (сначала MinIO, потом Tarantool) решает эту проблему, но создает другую: при сбое на этапе записи в Tarantool в MinIO остается "осиротевший" объект. Однако это приемлемо, так как механизмы TTL (Time-To-Live) в конечном итоге удалят такие объекты, и это не влияет на корректность доставки сообщений.

Use case для публикации сообщений (`internal/usecase/publish_usecase.go:59-136`) реализует критическую логику предотвращения race condition:

```go
// ВАЖНО: Порядок операций для предотвращения race condition:
// 1. Выделить sequence number
// 2. Загрузить payload в MinIO (если присутствует)
// 3. Вставить метаданные в Tarantool
// Это гарантирует, что метаданные появляются только после доступности payload
func (uc *PublishUseCase) Publish(ctx context.Context, req *PublishRequest) (*PublishResponse, error) {
    if req == nil {
        return nil, fmt.Errorf("request cannot be nil")
    }

    if req.Subject == "" {
        return nil, fmt.Errorf("subject cannot be empty")
    }

    uc.logger.Info("Publishing message",
        logger.String("subject", req.Subject),
        logger.Int("data_size", len(req.Data)),
    )

    // Шаг 1: Выделение sequence number из Tarantool
    sequence, err := uc.messageRepo.GetNextSequence()
    if err != nil {
        uc.logger.Error("Failed to get next sequence",
            logger.String("subject", req.Subject),
            logger.Error(err),
        )
        return nil, fmt.Errorf("failed to get next sequence: %w", err)
    }

    // Генерация имени объекта на основе subject и sequence
    objectName := fmt.Sprintf("%s_%d", req.Subject, sequence)

    // Шаг 2: Загрузка данных в MinIO (ДО вставки метаданных)
    if len(req.Data) > 0 {
        contentType := "application/octet-stream"
        if ct, ok := req.Headers["content-type"]; ok {
            contentType = ct
        }

        err = uc.storageRepo.UploadData(ctx, objectName, req.Data, contentType)
        if err != nil {
            uc.logger.Error("Failed to upload data to storage",
                logger.String("subject", req.Subject),
                logger.Uint64("sequence", sequence),
                logger.String("object_name", objectName),
                logger.Error(err),
            )
            // ПРИМЕЧАНИЕ: sequence "сгорает" здесь (пробел в последовательности)
            // Это приемлемо для предотвращения race condition
            return nil, fmt.Errorf("failed to upload data: %w", err)
        }
    }

    // Шаг 3: Вставка метаданных сообщения в Tarantool (ПОСЛЕ загрузки payload)
    err = uc.messageRepo.InsertMessage(sequence, req.Subject, req.Headers, objectName)
    if err != nil {
        uc.logger.Error("Failed to insert message metadata",
            logger.String("subject", req.Subject),
            logger.Uint64("sequence", sequence),
            logger.Error(err),
        )
        // ПРИМЕЧАНИЕ: Объект MinIO существует, но метаданные отсутствуют
        // TTL cleanup в конечном итоге удалит осиротевшие объекты
        return nil, fmt.Errorf("failed to insert message metadata: %w", err)
    }

    uc.logger.Info("Message published successfully",
        logger.String("subject", req.Subject),
        logger.Uint64("sequence", sequence),
        logger.String("object_name", objectName),
    )

    return &PublishResponse{
        Sequence:   sequence,
        ObjectName: objectName,
    }, nil
}
```

Ключевые аспекты реализации:

1. **Предотвращение race condition**: Payload загружается в MinIO перед вставкой метаданных в Tarantool, гарантируя, что subscribers никогда не получат notification о сообщении, данные которого еще не доступны.

2. **Обработка ошибок**: Если загрузка в MinIO не удается, sequence number "сгорает", создавая пробел в последовательности. Это приемлемо, так как предотвращает более серьезную проблему несогласованности данных.

3. **Orphaned objects**: Если вставка метаданных не удается после успешной загрузки в MinIO, объект остается "осиротевшим". TTL механизмы в конечном итоге очистят такие объекты.

### 3.1.7 Реализация gRPC Handler

gRPC Handler (`internal/delivery/grpc/handler.go:31-115`) принимает запросы от клиентов и делегирует обработку use case:

```go
func (h *IngressHandler) Publish(ctx context.Context, req *pb.PublishRequest) (*pb.PublishResponse, error) {
    // Проверка авторизации если claims присутствуют в контексте
    if claims, ok := auth.GetClaimsFromContext(ctx); ok {
        h.logger.Info("Received authenticated Publish request",
            logger.String("subject", req.Subject),
            logger.String("client_id", claims.ClientID),
            logger.Int("data_size", len(req.Data)),
            logger.Int("headers_count", len(req.Headers)),
        )

        // Валидация прав на публикацию
        if err := claims.ValidatePublishAccess(req.Subject); err != nil {
            h.logger.Warn("Publish permission denied",
                logger.String("subject", req.Subject),
                logger.String("client_id", claims.ClientID),
                logger.Error(err),
            )
            return nil, status.Errorf(codes.PermissionDenied, "publish permission denied")
        }
    } else {
        h.logger.Info("Received unauthenticated Publish request",
            logger.String("subject", req.Subject),
            logger.Int("data_size", len(req.Data)),
            logger.Int("headers_count", len(req.Headers)),
        )
    }

    // Валидация запроса
    if req.Subject == "" {
        h.logger.Warn("Publish request rejected: empty subject")
        return &pb.PublishResponse{
            Sequence:     0,
            ObjectName:   "",
            StatusCode:   1,
            ErrorMessage: "subject cannot be empty",
        }, nil
    }

    // Конвертация headers из proto map в Go map
    headers := make(map[string]string)
    for k, v := range req.Headers {
        headers[k] = v
    }

    // Добавление размера данных в headers
    if len(req.Data) > 0 {
        headers["data-size"] = fmt.Sprintf("%d", len(req.Data))
    }

    // Вызов use case
    ucReq := &usecase.PublishRequest{
        Subject: req.Subject,
        Data:    req.Data,
        Headers: headers,
    }

    resp, err := h.publishUC.Publish(ctx, ucReq)
    if err != nil {
        h.logger.Error("Publish use case failed",
            logger.String("subject", req.Subject),
            logger.Error(err),
        )
        return &pb.PublishResponse{
            Sequence:     0,
            ObjectName:   "",
            StatusCode:   1,
            ErrorMessage: err.Error(),
        }, nil
    }

    h.logger.Info("Publish request completed successfully",
        logger.String("subject", req.Subject),
        logger.Uint64("sequence", resp.Sequence),
        logger.String("object_name", resp.ObjectName),
    )

    // Возврат ответа
    return &pb.PublishResponse{
        Sequence:     resp.Sequence,
        ObjectName:   resp.ObjectName,
        StatusCode:   0,
        ErrorMessage: "",
    }, nil
}
```

Handler выполняет следующие функции:

1. **Аутентификация и авторизация**: Проверяет наличие JWT claims в контексте и валидирует права доступа к subject.
2. **Валидация запроса**: Проверяет обязательные поля.
3. **Преобразование данных**: Конвертирует protobuf структуры в доменные модели.
4. **Логирование**: Детальное логирование всех операций для аудита и отладки.
5. **Обработка ошибок**: Грациозная обработка ошибок с понятными сообщениями для клиентов.

### 3.1.8 Конфигурация TTL и автоматическая очистка

Ingress Service настраивает TTL политики для автоматической очистки старых сообщений (`cmd/server/main.go:136-154`):

```go
// Настройка MinIO lifecycle policies для TTL
if cfg.TTL.Enabled {
    appLogger.Info("Setting up MinIO TTL policies")
    if err := storageRepo.SetupTTLPolicies(ctx, cfg.TTL); err != nil {
        appLogger.Error("Failed to setup MinIO TTL policies", logger.Error(err))
    } else {
        appLogger.Info("MinIO TTL policies configured successfully")
    }
}

// Инициализация фонового процесса TTL cleanup в Tarantool
if cfg.TTL.Enabled {
    appLogger.Info("Starting Tarantool TTL cleanup fiber")
    if err := messageRepo.StartTTLCleanup(cfg.TTL); err != nil {
        appLogger.Error("Failed to start Tarantool TTL cleanup", logger.Error(err))
    } else {
        appLogger.Info("Tarantool TTL cleanup fiber started")
    }
}
```

Реализация TTL для MinIO (`internal/repository/minio/client.go:201-282`) создает lifecycle правила:

```go
func (r *Repository) SetupTTLPolicies(ctx context.Context, ttlConfig config.TTLConfig) error {
    bucketName := r.config.BucketName

    r.logger.Info("Setting up MinIO lifecycle policies",
        logger.String("bucket", bucketName),
        logger.Any("default_ttl", ttlConfig.Default),
    )

    // Создание lifecycle конфигурации
    config := lifecycle.NewConfiguration()
    var rules []lifecycle.Rule

    // Добавление default правила для всех объектов
    if ttlConfig.Default > 0 {
        defaultRule := lifecycle.Rule{
            ID:     "default-ttl",
            Status: "Enabled",
            Expiration: lifecycle.Expiration{
                Days: lifecycle.ExpirationDays(int(ttlConfig.Default.Hours() / 24)),
            },
        }
        rules = append(rules, defaultRule)
        r.logger.Info("Added default TTL rule",
            logger.String("rule_id", "default-ttl"),
            logger.Int("days", int(ttlConfig.Default.Hours()/24)),
        )
    }

    // Добавление per-channel правил
    for _, channelTTL := range ttlConfig.Channels {
        if channelTTL.Duration <= 0 {
            continue
        }

        // Объекты именуются как "{channel}_{sequence}"
        // Используем prefix фильтр для сопоставления channel
        channelRule := lifecycle.Rule{
            ID:     fmt.Sprintf("channel-%s-ttl", channelTTL.Channel),
            Status: "Enabled",
            Expiration: lifecycle.Expiration{
                Days: lifecycle.ExpirationDays(int(channelTTL.Duration.Hours() / 24)),
            },
            RuleFilter: lifecycle.Filter{
                And: lifecycle.And{
                    Prefix: channelTTL.Channel + "_",
                },
            },
        }
        rules = append(rules, channelRule)
        r.logger.Info("Added channel-specific TTL rule",
            logger.String("rule_id", channelRule.ID),
            logger.String("channel", channelTTL.Channel),
            logger.String("prefix", channelTTL.Channel+"_"),
            logger.Int("days", int(channelTTL.Duration.Hours()/24)),
        )
    }

    if len(rules) == 0 {
        r.logger.Warn("No TTL rules to apply")
        return nil
    }

    config.Rules = rules

    // Применение lifecycle конфигурации
    err := r.client.SetBucketLifecycle(ctx, bucketName, config)
    if err != nil {
        r.logger.Error("Failed to set bucket lifecycle",
            logger.String("bucket", bucketName),
            logger.Error(err),
        )
        return fmt.Errorf("failed to set bucket lifecycle: %w", err)
    }

    r.logger.Info("Successfully configured MinIO lifecycle policies",
        logger.String("bucket", bucketName),
        logger.Int("rules_count", len(rules)),
    )

    return nil
}
```

---

## 3.2 Реализация точки выхода (Egress Service)

Egress Service представляет собой вторую критически важную часть системы MiniToolStream, отвечающую за доставку сообщений потребителям. В отличие от Ingress Service, который имеет одну точку входа (метод Publish), Egress Service предоставляет несколько способов получения сообщений, каждый из которых оптимизирован для определенных сценариев использования.

### 3.2.1 Архитектура Egress Service

Egress Service имеет аналогичную Ingress структуру слоев, что обеспечивает единообразие кодовой базы и упрощает поддержку обоих сервисов. Однако бизнес-логика существенно отличается, так как сервис должен решать задачи, обратные задачам Ingress:

- **Subscribe** - streaming API с push-моделью доставки. Этот метод создает долгоживущее соединение, через которое сервер активно отправляет уведомления о новых сообщениях. Подходит для реактивных систем, требующих минимальной задержки между публикацией и обработкой сообщений.

- **Fetch** - batch API для pull-модели с явным acknowledgment (ACK). Клиент сам контролирует, когда получать сообщения, что удобно для batch-обработки или систем с переменной нагрузкой. Критически важно, что этот метод реализует семантику At-Least-Once delivery через механизм явного подтверждения.

- **GetLastSequence** - вспомогательный метод для получения последнего sequence number для заданного subject. Позволяет клиентам определить, сколько новых сообщений доступно для обработки.

- **AckMessage** - метод явного подтверждения обработки сообщения. Обновляет позицию чтения durable consumer, что обеспечивает надежность доставки при сбоях клиентских приложений.

### 3.2.2 Реализация Subscribe (Push-модель)

Handler для Subscribe (`internal/delivery/grpc/handler.go:33-110`) создает streaming соединение:

```go
func (h *EgressHandler) Subscribe(req *pb.SubscribeRequest, stream pb.EgressService_SubscribeServer) error {
    // Проверка авторизации
    if claims, ok := auth.GetClaimsFromContext(stream.Context()); ok {
        h.logger.Info("Authenticated Subscribe request",
            logger.String("subject", req.Subject),
            logger.String("client_id", claims.ClientID),
            logger.String("durable_name", req.DurableName),
        )

        // Валидация прав на подписку
        if err := claims.ValidateSubscribeAccess(req.Subject); err != nil {
            h.logger.Warn("Subscribe permission denied",
                logger.String("subject", req.Subject),
                logger.String("client_id", claims.ClientID),
                logger.Error(err),
            )
            return status.Errorf(codes.PermissionDenied, "subscribe permission denied")
        }
    } else {
        h.logger.Info("Unauthenticated Subscribe request",
            logger.String("subject", req.Subject),
            logger.String("durable_name", req.DurableName),
        )
    }

    if req.Subject == "" {
        return fmt.Errorf("subject cannot be empty")
    }

    if req.DurableName == "" {
        return fmt.Errorf("durable_name cannot be empty")
    }

    // Создание канала для уведомлений
    notificationChan := make(chan *entity.Notification, 100)
    defer close(notificationChan)

    // Запуск подписки в goroutine
    ctx, cancel := context.WithCancel(stream.Context())
    defer cancel()

    errChan := make(chan error, 1)
    go func() {
        err := h.messageUC.Subscribe(ctx, req.Subject, req.DurableName, req.StartSequence, notificationChan)
        if err != nil && err != context.Canceled {
            errChan <- err
        }
        close(errChan)
    }()

    // Пересылка уведомлений в gRPC stream
    for {
        select {
        case notification, ok := <-notificationChan:
            if !ok {
                return nil
            }

            err := stream.Send(&pb.Notification{
                Subject:  notification.Subject,
                Sequence: notification.Sequence,
            })
            if err != nil {
                return fmt.Errorf("failed to send notification: %w", err)
            }

        case err := <-errChan:
            if err != nil {
                return err
            }
            return nil

        case <-ctx.Done():
            return ctx.Err()
        }
    }
}
```

Use case для Subscribe (`internal/usecase/message_usecase.go:36-114`) реализует polling механизм:

```go
func (uc *MessageUseCase) Subscribe(
    ctx context.Context,
    subject string,
    durableName string,
    startSequence *uint64,
    notificationChan chan<- *entity.Notification,
) error {
    // Получение начальной позиции consumer
    lastSequence, err := uc.messageRepo.GetConsumerPosition(ctx, durableName, subject)
    if err != nil {
        return fmt.Errorf("failed to get consumer position: %w", err)
    }

    // Использование start_sequence если предоставлено
    if startSequence != nil && *startSequence > lastSequence {
        lastSequence = *startSequence
    }

    uc.logger.Info("Starting subscription",
        logger.String("subject", subject),
        logger.String("durable_name", durableName),
        logger.Uint64("start_sequence", lastSequence),
    )

    // Отправка начального уведомления если есть сообщения
    latestSeq, err := uc.messageRepo.GetLatestSequenceForSubject(ctx, subject)
    if err != nil {
        return fmt.Errorf("failed to get latest sequence: %w", err)
    }

    if latestSeq > lastSequence {
        select {
        case notificationChan <- &entity.Notification{
            Subject:  subject,
            Sequence: latestSeq,
        }:
            lastSequence = latestSeq
        case <-ctx.Done():
            return ctx.Err()
        }
    }

    // Цикл polling
    ticker := time.NewTicker(uc.pollInterval)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            uc.logger.Info("Subscription cancelled", logger.String("subject", subject))
            return ctx.Err()

        case <-ticker.C:
            // Проверка новых сообщений
            latestSeq, err := uc.messageRepo.GetLatestSequenceForSubject(ctx, subject)
            if err != nil {
                uc.logger.Error("Failed to get latest sequence", logger.Error(err))
                continue
            }

            if latestSeq > lastSequence {
                select {
                case notificationChan <- &entity.Notification{
                    Subject:  subject,
                    Sequence: latestSeq,
                }:
                    uc.logger.Debug("Sent notification",
                        logger.String("subject", subject),
                        logger.Uint64("sequence", latestSeq),
                    )
                    lastSequence = latestSeq
                case <-ctx.Done():
                    return ctx.Err()
                }
            }
        }
    }
}
```

Ключевые особенности:

1. **Durable Subscriptions**: Позиция чтения сохраняется в Tarantool по паре (durable_name, subject).
2. **Start Sequence**: Клиент может указать начальную позицию для чтения.
3. **Polling Interval**: Конфигурируемый интервал проверки новых сообщений.
4. **Graceful Cancellation**: Корректная обработка отмены контекста.

### 3.2.3 Реализация Fetch (Pull-модель с явным ACK)

Handler для Fetch (`internal/delivery/grpc/handler.go:112-181`) реализует batch-получение сообщений:

```go
func (h *EgressHandler) Fetch(req *pb.FetchRequest, stream pb.EgressService_FetchServer) error {
    // Проверка авторизации
    if claims, ok := auth.GetClaimsFromContext(stream.Context()); ok {
        h.logger.Info("Authenticated Fetch request",
            logger.String("subject", req.Subject),
            logger.String("client_id", claims.ClientID),
            logger.String("durable_name", req.DurableName),
            logger.Int("batch_size", int(req.BatchSize)),
        )

        // Валидация прав на fetch
        if err := claims.ValidateFetchAccess(req.Subject); err != nil {
            h.logger.Warn("Fetch permission denied",
                logger.String("subject", req.Subject),
                logger.String("client_id", claims.ClientID),
                logger.Error(err),
            )
            return status.Errorf(codes.PermissionDenied, "fetch permission denied")
        }
    } else {
        h.logger.Info("Unauthenticated Fetch request",
            logger.String("subject", req.Subject),
            logger.String("durable_name", req.DurableName),
            logger.Int("batch_size", int(req.BatchSize)),
        )
    }

    if req.Subject == "" {
        return fmt.Errorf("subject cannot be empty")
    }

    if req.DurableName == "" {
        return fmt.Errorf("durable_name cannot be empty")
    }

    // Получение сообщений
    messages, err := h.messageUC.FetchMessages(
        stream.Context(),
        req.Subject,
        req.DurableName,
        int(req.BatchSize),
    )
    if err != nil {
        return fmt.Errorf("failed to fetch messages: %w", err)
    }

    // Отправка каждого сообщения
    for _, msg := range messages {
        pbMsg := &pb.Message{
            Subject:   msg.Subject,
            Sequence:  msg.Sequence,
            Data:      msg.Data,
            Headers:   msg.Headers,
            Timestamp: timestamppb.New(msg.Timestamp),
        }

        err = stream.Send(pbMsg)
        if err != nil {
            return fmt.Errorf("failed to send message: %w", err)
        }
    }

    h.logger.Info("Fetch completed",
        logger.String("subject", req.Subject),
        logger.Int("count", len(messages)),
    )

    return nil
}
```

Use case для FetchMessages (`internal/usecase/message_usecase.go:116-175`) реализует критическую логику At-Least-Once delivery:

```go
func (uc *MessageUseCase) FetchMessages(
    ctx context.Context,
    subject string,
    durableName string,
    batchSize int,
) ([]*entity.Message, error) {
    if batchSize <= 0 {
        batchSize = 10 // Default batch size
    }

    // Получение позиции consumer
    lastSequence, err := uc.messageRepo.GetConsumerPosition(ctx, durableName, subject)
    if err != nil {
        return nil, fmt.Errorf("failed to get consumer position: %w", err)
    }

    uc.logger.Debug("Fetching messages",
        logger.String("subject", subject),
        logger.String("durable_name", durableName),
        logger.Uint64("last_sequence", lastSequence),
        logger.Int("batch_size", batchSize),
    )

    // Получение сообщений из repository
    messages, err := uc.messageRepo.GetMessagesBySubject(ctx, subject, lastSequence+1, batchSize)
    if err != nil {
        return nil, fmt.Errorf("failed to fetch messages: %w", err)
    }

    // Загрузка данных из storage для каждого сообщения
    // ВАЖНО: Позиция НЕ обновляется здесь - consumer должен явно ACK
    // Это обеспечивает семантику At-Least-Once delivery
    for _, msg := range messages {
        if msg.ObjectName != "" {
            data, err := uc.storageRepo.GetObject(ctx, msg.Subject, msg.ObjectName)
            if err != nil {
                uc.logger.Error("Failed to get data from storage - stopping batch processing",
                    logger.String("object_name", msg.ObjectName),
                    logger.Uint64("sequence", msg.Sequence),
                    logger.Error(err),
                )
                // Не возвращаем сообщения - клиент еще ничего не обработал
                return nil, fmt.Errorf("failed to fetch payload for sequence %d: %w", msg.Sequence, err)
            }
            msg.Data = data
        }

        // ПРИМЕЧАНИЕ: Позиция НЕ обновляется автоматически!
        // Consumer должен вызвать AckMessage после успешной обработки
        // Это предотвращает потерю сообщений при сбое consumer во время обработки
    }

    uc.logger.Info("Fetched messages",
        logger.String("subject", subject),
        logger.Int("count", len(messages)),
    )

    return messages, nil
}
```

### 3.2.4 Реализация явного ACK

Handler для AckMessage (`internal/delivery/grpc/handler.go:201-257`) обрабатывает подтверждения:

```go
func (h *EgressHandler) AckMessage(ctx context.Context, req *pb.AckRequest) (*pb.AckResponse, error) {
    // Проверка авторизации
    if claims, ok := auth.GetClaimsFromContext(ctx); ok {
        h.logger.Debug("Authenticated AckMessage request",
            logger.String("subject", req.Subject),
            logger.String("durable_name", req.DurableName),
            logger.Uint64("sequence", req.Sequence),
            logger.String("client_id", claims.ClientID),
        )
    } else {
        h.logger.Debug("Unauthenticated AckMessage request",
            logger.String("subject", req.Subject),
            logger.String("durable_name", req.DurableName),
            logger.Uint64("sequence", req.Sequence),
        )
    }

    if req.Subject == "" {
        return &pb.AckResponse{
            Success:      false,
            ErrorMessage: "subject cannot be empty",
        }, nil
    }

    if req.DurableName == "" {
        return &pb.AckResponse{
            Success:      false,
            ErrorMessage: "durable_name cannot be empty",
        }, nil
    }

    // Обновление позиции consumer
    err := h.messageUC.AckMessage(ctx, req.DurableName, req.Subject, req.Sequence)
    if err != nil {
        h.logger.Warn("Failed to acknowledge message",
            logger.String("durable_name", req.DurableName),
            logger.String("subject", req.Subject),
            logger.Uint64("sequence", req.Sequence),
            logger.Error(err),
        )
        return &pb.AckResponse{
            Success:      false,
            ErrorMessage: err.Error(),
        }, nil
    }

    h.logger.Info("Message acknowledged",
        logger.String("durable_name", req.DurableName),
        logger.String("subject", req.Subject),
        logger.Uint64("sequence", req.Sequence),
    )

    return &pb.AckResponse{
        Success: true,
    }, nil
}
```

Use case для AckMessage (`internal/usecase/message_usecase.go:192-207`):

```go
// AckMessage подтверждает сообщение обновлением позиции consumer
// Это обеспечивает семантику At-Least-Once delivery
func (uc *MessageUseCase) AckMessage(ctx context.Context, durableName, subject string, sequence uint64) error {
    err := uc.messageRepo.UpdateConsumerPosition(ctx, durableName, subject, sequence)
    if err != nil {
        return fmt.Errorf("failed to update consumer position: %w", err)
    }

    uc.logger.Debug("Message acknowledged",
        logger.String("durable_name", durableName),
        logger.String("subject", subject),
        logger.Uint64("sequence", sequence),
    )

    return nil
}
```

Этот механизм обеспечивает **At-Least-Once delivery semantics** (семантику доставки "как минимум один раз"):

**Принцип работы At-Least-Once delivery:**

1. **Доставка без автоматического подтверждения**: Когда клиент вызывает метод Fetch, сервер возвращает пакет сообщений, начиная с позиции, сохраненной для данного durable consumer. Критически важно, что позиция чтения НЕ обновляется автоматически. Это означает, что с точки зрения сервера клиент еще не обработал эти сообщения.

2. **Обработка клиентом**: Клиент получает сообщения и начинает их обработку. Обработка может включать сложные бизнес-операции, запись в базу данных, отправку HTTP запросов и т.д.

3. **Явное подтверждение**: Только после успешного завершения обработки клиент вызывает метод AckMessage для каждого обработанного сообщения (или для последнего сообщения в пакете, если обработка идет последовательно).

4. **Обновление позиции**: Сервер обновляет сохраненную позицию durable consumer только после получения явного ACK. С этого момента при следующем вызове Fetch клиент получит новые сообщения.

5. **Гарантии при сбоях**: Если клиентское приложение упало в процессе обработки (после получения сообщений, но до отправки ACK), при следующем запуске оно получит те же самые сообщения снова. Это гарантирует, что ни одно сообщение не будет потеряно из-за сбоя клиента.

**Важные следствия At-Least-Once семантики:**

- Клиентская логика должна быть идемпотентной, так как одно и то же сообщение может быть обработано несколько раз.
- Это предпочтительная семантика для критически важных данных, где потеря сообщения недопустима.
- Производительность может быть ниже, чем у At-Most-Once, из-за дополнительных операций подтверждения, но надежность значительно выше.

---

## 3.3 Реализация слоя безопасности (JWT Layer)

Безопасность является критически важным аспектом любой распределенной системы, обрабатывающей потенциально конфиденциальные данные. В системе MiniToolStream реализован комплексный многоуровневый подход к безопасности, основанный на индустриальных стандартах и best practices.

### 3.3.1 Архитектура JWT аутентификации

Для аутентификации и авторизации клиентов выбран подход на основе JSON Web Tokens (JWT) - широко распространенный стандарт для безопасной передачи информации между сторонами. JWT токены являются самодостаточными (self-contained), что означает, что вся необходимая информация для проверки подлинности и прав доступа содержится в самом токене, без необходимости обращения к базе данных при каждом запросе.

Преимущества использования JWT в контексте MiniToolStream:

- **Stateless аутентификация**: Сервер не хранит сессии, что упрощает горизонтальное масштабирование
- **Распределенная валидация**: Любой экземпляр сервиса может независимо валидировать токен, имея только публичный ключ
- **Встроенные права доступа**: Claims токена содержат всю информацию о разрешениях, что позволяет принимать решения об авторизации без дополнительных запросов
- **Временные ограничения**: Токены имеют срок действия, что снижает риски при компрометации

Слой безопасности реализован в пакете `auth` библиотеки MiniToolStreamConnector и включает:

- **JWT Manager** - централизованный компонент для генерации и валидации токенов, использующий криптографию RSA-256
- **Claims** - типизированная структура прав доступа, содержащая идентификатор клиента, разрешенные subjects и permissions
- **Interceptors** - gRPC interceptors для автоматической проверки токенов на каждом запросе без вмешательства в бизнес-логику
- **Permissions** - гибкая система валидации прав на операции с поддержкой wildcard patterns

### 3.3.2 JWT Manager и работа с ключами

Реализация JWTManager (`auth/jwt.go:34-78`) использует RSA-256 для подписи:

```go
type JWTManager struct {
    privateKey *rsa.PrivateKey
    publicKey  *rsa.PublicKey
    issuer     string
    vaultPath  string // Путь для хранения/получения ключей из Vault
}

func NewJWTManager(cfg *JWTConfig) (*JWTManager, error) {
    if cfg.Issuer == "" {
        cfg.Issuer = "minitoolstream"
    }

    jm := &JWTManager{
        issuer:    cfg.Issuer,
        vaultPath: cfg.VaultPath,
    }

    // Использование предоставленных ключей или генерация новых
    if cfg.PrivateKey != nil {
        jm.privateKey = cfg.PrivateKey
        jm.publicKey = &cfg.PrivateKey.PublicKey
    } else if cfg.PublicKey != nil {
        jm.publicKey = cfg.PublicKey
    } else {
        // Генерация новой RSA ключевой пары
        privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
        if err != nil {
            return nil, fmt.Errorf("failed to generate RSA key: %w", err)
        }
        jm.privateKey = privateKey
        jm.publicKey = &privateKey.PublicKey
    }

    return jm, nil
}
```

**Интеграция с Vault** (`auth/jwt.go:80-140`) обеспечивает централизованное управление ключами:

```go
func NewJWTManagerFromVault(ctx context.Context, vaultClient *vault.Client, vaultPath, issuer string) (*JWTManager, error) {
    if vaultPath == "" {
        vaultPath = "secret/data/minitoolstream/jwt"
    }

    // Попытка чтения существующих ключей из Vault
    secret, err := vaultClient.Logical().ReadWithContext(ctx, vaultPath)
    if err != nil {
        return nil, fmt.Errorf("failed to read from Vault: %w", err)
    }

    jm := &JWTManager{
        issuer:    issuer,
        vaultPath: vaultPath,
    }

    // Если ключи существуют в Vault, загружаем их
    if secret != nil && secret.Data != nil {
        data, ok := secret.Data["data"].(map[string]interface{})
        if ok {
            privateKeyPEM, _ := data["private_key"].(string)
            publicKeyPEM, _ := data["public_key"].(string)

            if privateKeyPEM != "" {
                privateKey, err := parseRSAPrivateKeyFromPEM([]byte(privateKeyPEM))
                if err != nil {
                    return nil, fmt.Errorf("failed to parse private key from Vault: %w", err)
                }
                jm.privateKey = privateKey
            }

            if publicKeyPEM != "" {
                publicKey, err := parseRSAPublicKeyFromPEM([]byte(publicKeyPEM))
                if err != nil {
                    return nil, fmt.Errorf("failed to parse public key from Vault: %w", err)
                }
                jm.publicKey = publicKey
            }
        }
    }

    // Если ключи не найдены, генерируем и сохраняем в Vault
    if jm.privateKey == nil {
        privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
        if err != nil {
            return nil, fmt.Errorf("failed to generate RSA key: %w", err)
        }
        jm.privateKey = privateKey
        jm.publicKey = &privateKey.PublicKey

        // Сохранение в Vault
        if err := jm.SaveKeysToVault(ctx, vaultClient); err != nil {
            return nil, fmt.Errorf("failed to save keys to Vault: %w", err)
        }
    } else if jm.publicKey == nil {
        jm.publicKey = &jm.privateKey.PublicKey
    }

    return jm, nil
}
```

### 3.3.3 Структура Claims и permissions

Claims (`auth/jwt.go:26-32`) содержит информацию о правах клиента:

```go
type Claims struct {
    ClientID        string   `json:"client_id"`
    AllowedSubjects []string `json:"allowed_subjects,omitempty"` // Wildcard паттерны: "images.*", "logs.*"
    Permissions     []string `json:"permissions"`                // publish, subscribe, fetch
    jwt.RegisteredClaims
}
```

**Генерация токена** (`auth/jwt.go:142-164`):

```go
func (jm *JWTManager) GenerateToken(clientID string, allowedSubjects, permissions []string, duration time.Duration) (string, error) {
    if jm.privateKey == nil {
        return "", errors.New("private key not available for token generation")
    }

    now := time.Now()
    claims := &Claims{
        ClientID:        clientID,
        AllowedSubjects: allowedSubjects,
        Permissions:     permissions,
        RegisteredClaims: jwt.RegisteredClaims{
            Issuer:    jm.issuer,
            Subject:   clientID,
            IssuedAt:  jwt.NewNumericDate(now),
            ExpiresAt: jwt.NewNumericDate(now.Add(duration)),
            NotBefore: jwt.NewNumericDate(now),
        },
    }

    token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
    return token.SignedString(jm.privateKey)
}
```

**Валидация токена с проверкой RSA-256 подписи** (`auth/jwt.go:166-196`):

```go
func (jm *JWTManager) ValidateToken(tokenString string) (*Claims, error) {
    if jm.publicKey == nil {
        return nil, errors.New("public key not available for token validation")
    }

    token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
        // Проверка метода подписи
        if _, ok := token.Method.(*jwt.SigningMethodRSA); !ok {
            return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
        }
        return jm.publicKey, nil
    })

    if err != nil {
        if errors.Is(err, jwt.ErrTokenExpired) {
            return nil, ErrTokenExpired
        }
        if errors.Is(err, jwt.ErrSignatureInvalid) {
            return nil, ErrInvalidSignature
        }
        return nil, fmt.Errorf("%w: %v", ErrInvalidToken, err)
    }

    claims, ok := token.Claims.(*Claims)
    if !ok || !token.Valid {
        return nil, ErrInvalidToken
    }

    return claims, nil
}
```

### 3.3.4 Система разрешений с wildcard patterns

Реализация проверки прав доступа (`auth/permissions.go:15-39`):

```go
// CheckPermission проверяет наличие требуемого разрешения
func (c *Claims) CheckPermission(required string) bool {
    for _, perm := range c.Permissions {
        if perm == PermissionAll || perm == required {
            return true
        }
    }
    return false
}

// CheckSubjectAccess проверяет доступ к указанному subject
// Поддерживает wildcard паттерны: "images.*", "logs.system.*", и т.д.
func (c *Claims) CheckSubjectAccess(subject string) bool {
    // Если нет ограничений по subject, разрешаем все
    if len(c.AllowedSubjects) == 0 {
        return true
    }

    for _, pattern := range c.AllowedSubjects {
        if matchSubjectPattern(pattern, subject) {
            return true
        }
    }
    return false
}
```

**Wildcard matching** (`auth/permissions.go:41-70`):

```go
// matchSubjectPattern сопоставляет subject с паттерном с поддержкой wildcard
// Паттерны:
//   - "*" соответствует всему
//   - "images.*" соответствует "images.jpeg", "images.png", и т.д.
//   - "logs.system.*" соответствует "logs.system.error", "logs.system.info", и т.д.
//   - "exact.match" соответствует только "exact.match"
func matchSubjectPattern(pattern, subject string) bool {
    // Точное совпадение для wildcard
    if pattern == "*" {
        return true
    }

    // Точное совпадение
    if pattern == subject {
        return true
    }

    // Wildcard matching
    if strings.HasSuffix(pattern, ".*") {
        prefix := strings.TrimSuffix(pattern, ".*")
        // Соответствие если subject начинается с prefix и имеет правильный разделитель
        if strings.HasPrefix(subject, prefix+".") || subject == prefix {
            return true
        }
    }

    // Path-style matching для более сложных паттернов
    matched, _ := path.Match(pattern, subject)
    return matched
}
```

**Валидация конкретных операций** (`auth/permissions.go:72-103`):

```go
// ValidatePublishAccess валидирует права на публикацию в subject
func (c *Claims) ValidatePublishAccess(subject string) error {
    if !c.CheckPermission(PermissionPublish) {
        return ErrInsufficientPerms
    }
    if !c.CheckSubjectAccess(subject) {
        return ErrSubjectNotAllowed
    }
    return nil
}

// ValidateSubscribeAccess валидирует права на подписку на subject
func (c *Claims) ValidateSubscribeAccess(subject string) error {
    if !c.CheckPermission(PermissionSubscribe) {
        return ErrInsufficientPerms
    }
    if !c.CheckSubjectAccess(subject) {
        return ErrSubjectNotAllowed
    }
    return nil
}

// ValidateFetchAccess валидирует права на fetch из subject
func (c *Claims) ValidateFetchAccess(subject string) error {
    if !c.CheckPermission(PermissionFetch) {
        return ErrInsufficientPerms
    }
    if !c.CheckSubjectAccess(subject) {
        return ErrSubjectNotAllowed
    }
    return nil
}
```

### 3.3.5 gRPC Interceptors

**Unary Interceptor** для синхронных RPC (`auth/interceptor.go:21-39`):

```go
func UnaryServerInterceptor(jwtManager *JWTManager) grpc.UnaryServerInterceptor {
    return func(
        ctx context.Context,
        req interface{},
        info *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler,
    ) (interface{}, error) {
        claims, err := authenticate(ctx, jwtManager)
        if err != nil {
            return nil, err
        }

        // Добавление claims в контекст
        ctx = context.WithValue(ctx, ClaimsContextKey{}, claims)

        return handler(ctx, req)
    }
}
```

**Stream Interceptor** для streaming RPC (`auth/interceptor.go:41-62`):

```go
func StreamServerInterceptor(jwtManager *JWTManager) grpc.StreamServerInterceptor {
    return func(
        srv interface{},
        stream grpc.ServerStream,
        info *grpc.StreamServerInfo,
        handler grpc.StreamHandler,
    ) error {
        claims, err := authenticate(stream.Context(), jwtManager)
        if err != nil {
            return err
        }

        // Обертка stream с аутентифицированным контекстом
        wrappedStream := &authenticatedStream{
            ServerStream: stream,
            ctx:          context.WithValue(stream.Context(), ClaimsContextKey{}, claims),
        }

        return handler(srv, wrappedStream)
    }
}
```

**Функция аутентификации** (`auth/interceptor.go:74-98`):

```go
func authenticate(ctx context.Context, jwtManager *JWTManager) (*Claims, error) {
    md, ok := metadata.FromIncomingContext(ctx)
    if !ok {
        return nil, status.Error(codes.Unauthenticated, "missing metadata")
    }

    values := md.Get(authorizationHeader)
    if len(values) == 0 {
        return nil, status.Error(codes.Unauthenticated, "missing authorization header")
    }

    token := values[0]
    if !strings.HasPrefix(token, bearerPrefix) {
        return nil, status.Error(codes.Unauthenticated, "invalid authorization header format")
    }

    token = strings.TrimPrefix(token, bearerPrefix)
    claims, err := jwtManager.ValidateToken(token)
    if err != nil {
        return nil, status.Error(codes.Unauthenticated, err.Error())
    }

    return claims, nil
}
```

### 3.3.6 Условная аутентификация

В Ingress Service реализована условная аутентификация (`cmd/server/main.go:234-255`):

```go
func conditionalAuthInterceptor(jwtManager *auth.JWTManager, requireAuth bool) grpc.UnaryServerInterceptor {
    if requireAuth {
        // Требовать аутентификацию для всех запросов
        return auth.UnaryServerInterceptor(jwtManager)
    }

    // Опциональная аутентификация - валидировать если присутствует, разрешить если нет
    return func(
        ctx context.Context,
        req interface{},
        info *grpc.UnaryServerInfo,
        handler grpc.UnaryHandler,
    ) (interface{}, error) {
        // Попытка получить токен из metadata
        claims, _ := tryAuthenticate(ctx, jwtManager)
        if claims != nil {
            ctx = context.WithValue(ctx, auth.ClaimsContextKey{}, claims)
        }
        return handler(ctx, req)
    }
}
```

Это позволяет гибко настраивать режим работы:
- **Строгая аутентификация** (requireAuth=true): все запросы должны иметь валидный токен
- **Опциональная аутентификация** (requireAuth=false): запросы с токеном валидируются, запросы без токена разрешены

---

## 3.4 Реализация интеграции с HashiCorp Vault

### 3.4.1 Архитектура интеграции

Vault используется для хранения:
1. **Учетные данные Tarantool** (username, password)
2. **Учетные данные MinIO** (access_key_id, secret_access_key)
3. **JWT ключевая пара** (RSA private/public keys)

### 3.4.2 VaultClient реализация

Wrapper для Vault API (`internal/config/vault.go:10-46`):

```go
type VaultClient struct {
    client *vault.Client
    config *VaultConfig
}

func NewVaultClient(cfg *VaultConfig) (*VaultClient, error) {
    if !cfg.Enabled {
        return nil, nil // Vault отключен
    }

    vaultCfg := vault.DefaultConfig()
    vaultCfg.Address = cfg.Address

    client, err := vault.NewClient(vaultCfg)
    if err != nil {
        return nil, fmt.Errorf("failed to create vault client: %w", err)
    }

    // Установка токена
    token, err := cfg.GetVaultToken()
    if err != nil {
        return nil, err
    }
    client.SetToken(token)

    // Установка namespace при необходимости
    if cfg.Namespace != "" {
        client.SetNamespace(cfg.Namespace)
    }

    return &VaultClient{
        client: client,
        config: cfg,
    }, nil
}
```

### 3.4.3 Чтение секретов из KV v2

Метод для чтения секретов (`internal/config/vault.go:48-64`):

```go
func (vc *VaultClient) GetSecret(ctx context.Context, path string) (map[string]interface{}, error) {
    if vc == nil {
        return nil, fmt.Errorf("vault client is not initialized")
    }

    secret, err := vc.client.KVv2("secret").Get(ctx, path)
    if err != nil {
        return nil, fmt.Errorf("failed to read secret from vault: %w", err)
    }

    if secret == nil || secret.Data == nil {
        return nil, fmt.Errorf("secret not found: %s", path)
    }

    return secret.Data, nil
}
```

### 3.4.4 Сохранение JWT ключей в Vault

Реализация сохранения ключевой пары (`auth/jwt.go:198-227`):

```go
func (jm *JWTManager) SaveKeysToVault(ctx context.Context, vaultClient *vault.Client) error {
    if jm.vaultPath == "" {
        return errors.New("vault path not configured")
    }

    privateKeyPEM, err := exportRSAPrivateKeyToPEM(jm.privateKey)
    if err != nil {
        return fmt.Errorf("failed to export private key: %w", err)
    }

    publicKeyPEM, err := exportRSAPublicKeyToPEM(jm.publicKey)
    if err != nil {
        return fmt.Errorf("failed to export public key: %w", err)
    }

    data := map[string]interface{}{
        "data": map[string]interface{}{
            "private_key": string(privateKeyPEM),
            "public_key":  string(publicKeyPEM),
        },
    }

    _, err = vaultClient.Logical().WriteWithContext(ctx, jm.vaultPath, data)
    if err != nil {
        return fmt.Errorf("failed to write to Vault: %w", err)
    }

    return nil
}
```

### 3.4.5 PEM encoding/decoding

Helper функции для работы с RSA ключами в PEM формате (`auth/jwt.go:240-289`):

```go
func exportRSAPrivateKeyToPEM(key *rsa.PrivateKey) ([]byte, error) {
    if key == nil {
        return nil, errors.New("private key is nil")
    }
    privateKeyBytes := x509.MarshalPKCS1PrivateKey(key)
    privateKeyPEM := pem.EncodeToMemory(&pem.Block{
        Type:  "RSA PRIVATE KEY",
        Bytes: privateKeyBytes,
    })
    return privateKeyPEM, nil
}

func exportRSAPublicKeyToPEM(key *rsa.PublicKey) ([]byte, error) {
    if key == nil {
        return nil, errors.New("public key is nil")
    }
    publicKeyBytes, err := x509.MarshalPKIXPublicKey(key)
    if err != nil {
        return nil, err
    }
    publicKeyPEM := pem.EncodeToMemory(&pem.Block{
        Type:  "RSA PUBLIC KEY",
        Bytes: publicKeyBytes,
    })
    return publicKeyPEM, nil
}

func parseRSAPrivateKeyFromPEM(keyPEM []byte) (*rsa.PrivateKey, error) {
    block, _ := pem.Decode(keyPEM)
    if block == nil {
        return nil, errors.New("failed to decode PEM block")
    }
    return x509.ParsePKCS1PrivateKey(block.Bytes)
}

func parseRSAPublicKeyFromPEM(keyPEM []byte) (*rsa.PublicKey, error) {
    block, _ := pem.Decode(keyPEM)
    if block == nil {
        return nil, errors.New("failed to decode PEM block")
    }
    pub, err := x509.ParsePKIXPublicKey(block.Bytes)
    if err != nil {
        return nil, err
    }
    rsaPub, ok := pub.(*rsa.PublicKey)
    if !ok {
        return nil, errors.New("not an RSA public key")
    }
    return rsaPub, nil
}
```

### 3.4.6 Инициализация JWT Manager с Vault

Полная интеграция в сервисах (`cmd/server/main.go:219-232`):

```go
func initJWTManager(ctx context.Context, vaultClient *vault.Client, cfg *config.AuthConfig, log *logger.Logger) (*auth.JWTManager, error) {
    if vaultClient == nil {
        return nil, fmt.Errorf("vault client is required for JWT authentication")
    }

    log.Info("Loading JWT keys from Vault", logger.String("path", cfg.JWTVaultPath))
    jwtManager, err := auth.NewJWTManagerFromVault(ctx, vaultClient, cfg.JWTVaultPath, cfg.JWTIssuer)
    if err != nil {
        return nil, fmt.Errorf("failed to create JWT manager: %w", err)
    }

    return jwtManager, nil
}
```

---

## 3.5 Реализация гибридного слоя хранения

### 3.5.1 Архитектура разделения данных

Гибридное хранилище реализует разделение на два слоя:

**Tarantool (Metadata Layer)**:
- Sequence numbers (монотонно возрастающие счетчики)
- Message metadata (subject, headers, timestamp, object_name)
- Consumer positions (durable subscriptions)
- Secondary indices для быстрого поиска

**MinIO (Payload Layer)**:
- Бинарные данные сообщений
- Большие файлы
- Lifecycle policies для TTL
- S3-совместимый API

### 3.5.2 Tarantool API - функции на Lua

Tarantool space и функции определены в Lua (`tarantool/init.lua`):

```lua
-- Space для сообщений
box.schema.space.create('messages', {
    if_not_exists = true,
    format = {
        {name = 'sequence', type = 'unsigned'},
        {name = 'subject', type = 'string'},
        {name = 'headers', type = 'map'},
        {name = 'object_name', type = 'string'},
        {name = 'timestamp', type = 'number'}
    }
})

-- Индексы
box.space.messages:create_index('primary', {
    parts = {'sequence'},
    if_not_exists = true
})

box.space.messages:create_index('subject_sequence', {
    parts = {'subject', 'sequence'},
    unique = false,
    if_not_exists = true
})

-- Space для sequence generator
box.schema.space.create('sequence_generator', {
    if_not_exists = true,
    format = {
        {name = 'id', type = 'string'},
        {name = 'value', type = 'unsigned'}
    }
})

box.space.sequence_generator:create_index('primary', {
    parts = {'id'},
    if_not_exists = true
})

-- Функция получения следующего sequence
function get_next_sequence()
    local tuple = box.space.sequence_generator:get('global')
    if tuple == nil then
        box.space.sequence_generator:insert{'global', 1}
        return 1
    end

    local next_seq = tuple.value + 1
    box.space.sequence_generator:update('global', {{'=', 2, next_seq}})
    return next_seq
end

-- Функция вставки сообщения
function insert_message(sequence, subject, headers, object_name)
    local timestamp = fiber.time()
    box.space.messages:insert{
        sequence,
        subject,
        headers,
        object_name,
        timestamp
    }
    return true
end
```

### 3.5.3 Repository для Tarantool

Метод вызова Lua функций (`internal/repository/tarantool/client.go:94-112`):

```go
func (r *Repository) call(functionName string, args []interface{}) ([]interface{}, error) {
    r.mu.RLock()
    defer r.mu.RUnlock()

    if r.closed {
        return nil, fmt.Errorf("repository is closed")
    }

    // Использование Call17 для лучшей поддержки типов
    req := tarantool.NewCall17Request(functionName).Args(args)
    future := r.conn.Do(req)
    resp, err := future.Get()
    if err != nil {
        return nil, err
    }

    return resp, nil
}
```

### 3.5.4 Repository для MinIO

**Базовые операции с объектами**:

Загрузка объекта (уже показана в 3.1.5)

**Получение объекта** (`internal/repository/minio/repository.go` в Egress):

```go
func (r *Repository) GetObject(ctx context.Context, subject, objectName string) ([]byte, error) {
    bucketName := r.config.BucketName

    r.logger.Debug("Getting object from MinIO",
        logger.String("bucket", bucketName),
        logger.String("object", objectName),
    )

    // Получение объекта
    obj, err := r.client.GetObject(ctx, bucketName, objectName, minio.GetObjectOptions{})
    if err != nil {
        r.logger.Error("Failed to get object from MinIO",
            logger.String("bucket", bucketName),
            logger.String("object", objectName),
            logger.Error(err),
        )
        return nil, fmt.Errorf("failed to get object: %w", err)
    }
    defer obj.Close()

    // Чтение данных
    data, err := io.ReadAll(obj)
    if err != nil {
        r.logger.Error("Failed to read object data",
            logger.String("bucket", bucketName),
            logger.String("object", objectName),
            logger.Error(err),
        )
        return nil, fmt.Errorf("failed to read object data: %w", err)
    }

    r.logger.Debug("Object retrieved successfully",
        logger.String("bucket", bucketName),
        logger.String("object", objectName),
        logger.Int("size", len(data)),
    )

    return data, nil
}
```

### 3.5.5 Координация между слоями

Критическая последовательность операций в Use Case (повторение для акцента):

```
1. Ingress: GetNextSequence() от Tarantool
   ↓
2. Ingress: UploadData() в MinIO (если есть payload)
   ↓
3. Ingress: InsertMessage() в Tarantool (только после успешной загрузки)
   ↓
4. Egress: GetMessagesBySubject() из Tarantool (получает metadata)
   ↓
5. Egress: GetObject() из MinIO (загружает payload по object_name)
```

Эта последовательность гарантирует:
- **Нет race condition**: Metadata появляется только после доступности payload
- **Атомарность на уровне use case**: Все операции в рамках одной транзакции приложения
- **Graceful degradation**: При ошибках на любом этапе система остается в консистентном состоянии

---

## 3.6 Реализация клиентской библиотеки (Go SDK)

Клиентская библиотека представляет собой критически важный компонент системы, так как именно через нее пользователи взаимодействуют с MiniToolStream. Качество API библиотеки напрямую влияет на производительность труда разработчиков и скорость внедрения системы в production. Поэтому при проектировании библиотеки особое внимание было уделено удобству использования, безопасности и гибкости конфигурирования.

### 3.6.1 Архитектура библиотеки

Клиентская библиотека MiniToolStreamConnector организована по принципам Clean Architecture, что обеспечивает:

- **Независимость от транспортного уровня**: Domain interfaces не зависят от gRPC, что теоретически позволяет реализовать альтернативные транспорты (например, HTTP/REST) без изменения контрактов
- **Тестируемость**: Каждый слой может быть протестирован изолированно с использованием mock объектов
- **Расширяемость**: Новая функциональность добавляется без модификации существующего кода, следуя принципу Open/Closed из SOLID

Структура библиотеки:

```
minitoolstream_connector/
├── domain/              # Domain entities и interfaces
│   ├── publisher.go
│   └── subscriber.go
├── infrastructure/      # Реализации транспорта
│   └── grpc/
│       ├── ingress_client.go
│       ├── egress_client.go
│       └── interceptors.go
├── usecase/            # Бизнес-логика клиента
│   ├── publisher/
│   └── subscriber/
├── publisher.go        # Публичный API с Builder pattern
└── subscriber.go       # Публичный API с Builder pattern
```

### 3.6.2 Builder Pattern для Publisher

Одной из ключевых особенностей клиентской библиотеки является использование паттерна проектирования Builder для конфигурирования клиентов. Этот выбор обусловлен следующими причинами:

**Проблемы традиционных подходов к конфигурированию:**

- **Телескопические конструкторы**: При большом количестве параметров (адрес сервера, JWT токен, опции подключения, обработчики результатов и т.д.) традиционный подход с множественными конструкторами становится громоздким
- **Опциональные параметры**: Go не поддерживает опциональные параметры и default values для функций, что усложняет создание гибких API
- **Читаемость**: При вызове функции с 5-7 параметрами становится неочевидно, какое значение за что отвечает

**Преимущества Builder Pattern:**

- **Fluent Interface**: Цепочка методов `.WithJWTToken().WithBatchSize()` читается как обычный текст
- **Опциональная конфигурация**: Клиент может указать только те параметры, которые ему нужны
- **Валидация в одном месте**: Метод `Build()` централизованно проверяет корректность всех параметров
- **Иммутабельность**: После создания объект Publisher не может быть изменен, что предотвращает ошибки в многопоточном коде

Реализация PublisherBuilder (`minitoolstream_connector/publisher.go:58-124`):

```go
type PublisherBuilder struct {
    serverAddr    string
    jwtToken      string
    dialOpts      []grpc.DialOption
    resultHandler domain.ResultHandler
    err           error
}

// NewPublisherBuilder создает новый builder для publisher
func NewPublisherBuilder(serverAddr string) *PublisherBuilder {
    return &PublisherBuilder{
        serverAddr: serverAddr,
    }
}

// WithJWTToken устанавливает JWT токен для аутентификации
func (b *PublisherBuilder) WithJWTToken(token string) *PublisherBuilder {
    b.jwtToken = token
    return b
}

// WithDialOptions устанавливает custom dial options
func (b *PublisherBuilder) WithDialOptions(opts ...grpc.DialOption) *PublisherBuilder {
    b.dialOpts = opts
    return b
}

// WithResultHandler устанавливает custom result handler
func (b *PublisherBuilder) WithResultHandler(handler domain.ResultHandler) *PublisherBuilder {
    b.resultHandler = handler
    return b
}

// Build создает экземпляр publisher
func (b *PublisherBuilder) Build() (Publisher, error) {
    if b.err != nil {
        return nil, b.err
    }

    if b.serverAddr == "" {
        return nil, fmt.Errorf("server address is required")
    }

    // Создание gRPC клиента с поддержкой JWT
    client, err := grpcClient.NewIngressClientWithConfig(&grpcClient.IngressClientConfig{
        ServerAddr: b.serverAddr,
        JWTToken:   b.jwtToken,
        DialOpts:   b.dialOpts,
    })
    if err != nil {
        return nil, fmt.Errorf("failed to create gRPC client: %w", err)
    }

    // Создание publisher
    pub, err := publisher.New(&publisher.Config{
        Client:        client,
        ResultHandler: b.resultHandler,
    })
    if err != nil {
        client.Close()
        return nil, fmt.Errorf("failed to create publisher: %w", err)
    }

    return pub, nil
}
```

Пример использования:

```go
// Простое создание
publisher, err := minitoolstream.NewPublisher("localhost:50051")

// Создание с JWT аутентификацией через Builder
publisher, err := minitoolstream.NewPublisherBuilder("localhost:50051").
    WithJWTToken("eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...").
    WithResultHandler(func(result *PublishResult) {
        log.Printf("Published: seq=%d", result.Sequence)
    }).
    Build()
```

### 3.6.3 Builder Pattern для Subscriber

Реализация SubscriberBuilder (`minitoolstream_connector/subscriber.go:58-145`):

```go
type SubscriberBuilder struct {
    serverAddr  string
    jwtToken    string
    durableName string
    batchSize   int32
    dialOpts    []grpc.DialOption
    logger      subscriberUsecase.Logger
    err         error
}

// NewSubscriberBuilder создает новый builder для subscriber
func NewSubscriberBuilder(serverAddr string) *SubscriberBuilder {
    return &SubscriberBuilder{
        serverAddr: serverAddr,
        batchSize:  10,
    }
}

// WithJWTToken устанавливает JWT токен для аутентификации
func (b *SubscriberBuilder) WithJWTToken(token string) *SubscriberBuilder {
    b.jwtToken = token
    return b
}

// WithDurableName устанавливает durable name
func (b *SubscriberBuilder) WithDurableName(durableName string) *SubscriberBuilder {
    b.durableName = durableName
    return b
}

// WithBatchSize устанавливает batch size для fetching сообщений
func (b *SubscriberBuilder) WithBatchSize(batchSize int32) *SubscriberBuilder {
    b.batchSize = batchSize
    return b
}

// WithDialOptions устанавливает custom dial options
func (b *SubscriberBuilder) WithDialOptions(opts ...grpc.DialOption) *SubscriberBuilder {
    b.dialOpts = opts
    return b
}

// WithLogger устанавливает custom logger
func (b *SubscriberBuilder) WithLogger(logger subscriberUsecase.Logger) *SubscriberBuilder {
    b.logger = logger
    return b
}

// Build создает экземпляр subscriber
func (b *SubscriberBuilder) Build() (Subscriber, error) {
    if b.err != nil {
        return nil, b.err
    }

    if b.serverAddr == "" {
        return nil, fmt.Errorf("server address is required")
    }

    if b.durableName == "" {
        b.durableName = "default-subscriber"
    }

    // Создание gRPC клиента с поддержкой JWT
    client, err := grpcClient.NewEgressClientWithConfig(&grpcClient.EgressClientConfig{
        ServerAddr: b.serverAddr,
        JWTToken:   b.jwtToken,
        DialOpts:   b.dialOpts,
    })
    if err != nil {
        return nil, fmt.Errorf("failed to create gRPC client: %w", err)
    }

    // Создание subscriber
    sub, err := subscriberUsecase.New(&subscriberUsecase.Config{
        Client:      client,
        DurableName: b.durableName,
        BatchSize:   b.batchSize,
        Logger:      b.logger,
    })
    if err != nil {
        client.Close()
        return nil, fmt.Errorf("failed to create subscriber: %w", err)
    }

    return sub, nil
}
```

Пример использования:

```go
// Простое создание
subscriber, err := minitoolstream.NewSubscriber("localhost:50052", "my-service")

// Создание с JWT и custom настройками через Builder
subscriber, err := minitoolstream.NewSubscriberBuilder("localhost:50052").
    WithJWTToken("eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...").
    WithDurableName("image-processor").
    WithBatchSize(50).
    WithLogger(customLogger).
    Build()
```

### 3.6.4 Автоматическая авторизация через Interceptors

gRPC Client Interceptor для автоматического добавления JWT токена (`infrastructure/grpc/interceptors.go`):

```go
// UnaryClientInterceptor добавляет JWT токен в metadata для unary RPC
func UnaryClientInterceptor(jwtToken string) grpc.UnaryClientInterceptor {
    return func(
        ctx context.Context,
        method string,
        req, reply interface{},
        cc *grpc.ClientConn,
        invoker grpc.UnaryInvoker,
        opts ...grpc.CallOption,
    ) error {
        // Добавление токена в metadata
        ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+jwtToken)
        return invoker(ctx, method, req, reply, cc, opts...)
    }
}

// StreamClientInterceptor добавляет JWT токен в metadata для streaming RPC
func StreamClientInterceptor(jwtToken string) grpc.StreamClientInterceptor {
    return func(
        ctx context.Context,
        desc *grpc.StreamDesc,
        cc *grpc.ClientConn,
        method string,
        streamer grpc.Streamer,
        opts ...grpc.CallOption,
    ) (grpc.ClientStream, error) {
        // Добавление токена в metadata
        ctx = metadata.AppendToOutgoingContext(ctx, "authorization", "Bearer "+jwtToken)
        return streamer(ctx, desc, cc, method, opts...)
    }
}
```

Автоматическое применение при настройке клиента (`infrastructure/grpc/ingress_client.go:36-48`):

```go
func NewIngressClientWithConfig(cfg *IngressClientConfig) (*IngressClient, error) {
    if cfg.ServerAddr == "" {
        return nil, fmt.Errorf("server address is required")
    }

    opts := cfg.DialOpts

    // Добавление JWT interceptor если токен предоставлен
    if cfg.JWTToken != "" {
        opts = append(opts,
            grpc.WithUnaryInterceptor(UnaryClientInterceptor(cfg.JWTToken)),
        )
    }

    // ... остальной код подключения
}
```

Аналогично для Egress Client с StreamClientInterceptor.

### 3.6.5 Domain Interfaces

Чистые интерфейсы без зависимостей от инфраструктуры (`domain/publisher.go`):

```go
// Publisher interface для публикации сообщений
type Publisher interface {
    // Publish публикует сообщение
    Publish(ctx context.Context, msg *PublishMessage) (*PublishResult, error)

    // Close закрывает соединение
    Close() error
}

// PublishMessage представляет сообщение для публикации
type PublishMessage struct {
    Subject string
    Data    []byte
    Headers map[string]string
}

// PublishResult представляет результат публикации
type PublishResult struct {
    Sequence     uint64
    ObjectName   string
    StatusCode   int32
    ErrorMessage string
}
```

Интерфейсы для Subscriber (`domain/subscriber.go`):

```go
// Subscriber interface для подписки на сообщения
type Subscriber interface {
    // Subscribe создает streaming подписку
    Subscribe(ctx context.Context, subject string, handler MessageHandler) error

    // Fetch получает batch сообщений
    Fetch(ctx context.Context, subject string) ([]*ReceivedMessage, error)

    // Ack подтверждает обработку сообщения
    Ack(ctx context.Context, subject string, sequence uint64) error

    // Close закрывает соединение
    Close() error
}

// ReceivedMessage представляет полученное сообщение
type ReceivedMessage struct {
    Subject   string
    Sequence  uint64
    Data      []byte
    Headers   map[string]string
    Timestamp time.Time
}

// MessageHandler обрабатывает входящие сообщения
type MessageHandler interface {
    Handle(ctx context.Context, msg *ReceivedMessage) error
}
```

### 3.6.6 Преимущества Builder Pattern

1. **Fluent API**: Читаемая цепочка вызовов для конфигурации
2. **Опциональные параметры**: Не нужны многочисленные конструкторы
3. **Валидация**: Проверка параметров в методе Build()
4. **Иммутабельность**: Созданный объект не может быть изменен
5. **Расширяемость**: Легко добавлять новые параметры без breaking changes

---

## 3.7 Реализация утилит администрирования (JWT-gen)

### 3.7.1 Назначение утилиты

Управление безопасностью в распределенных системах требует специализированных инструментов, позволяющих администраторам безопасно генерировать учетные данные, управлять ключами шифрования и настраивать права доступа. Для системы MiniToolStream разработана консольная утилита `jwt-gen`, которая абстрагирует сложность работы с криптографическими ключами и JWT токенами, предоставляя простой и понятный command-line интерфейс.

**Основные функции утилиты:**

`jwt-gen` - консольная утилита для:

- **Генерации RSA ключевых пар и сохранения в Vault**: Автоматическое создание криптографически стойких ключей RSA-2048 и их безопасное хранение в HashiCorp Vault. Это критически важно для обеспечения единообразия ключей across всех экземпляров сервисов.

- **Генерации JWT токенов для клиентов**: Создание временных токенов доступа с гранулярным контролем прав. Каждый токен может быть настроен на специфический набор subjects и permissions, следуя принципу наименьших привилегий (principle of least privilege).

- **Просмотра публичного ключа из Vault**: Извлечение публичного ключа в PEM формате для распространения среди внешних систем, которым необходимо валидировать JWT токены без доступа к приватному ключу.

- **Управления правами доступа**: Гибкая настройка permissions (publish/subscribe/fetch) и allowed subjects с поддержкой wildcard patterns, позволяющая реализовать сложные политики безопасности.

### 3.7.2 Структура и параметры командной строки

Реализация (`tools/jwt-gen/main.go:16-27`):

```go
var (
    clientID        = flag.String("client", "", "Client ID (required)")
    subjects        = flag.String("subjects", "*", "Comma-separated list of allowed subjects (e.g., 'images.*,logs.*')")
    permissions     = flag.String("permissions", "publish,subscribe,fetch", "Comma-separated list of permissions")
    duration        = flag.Duration("duration", 24*time.Hour, "Token validity duration")
    vaultAddr       = flag.String("vault-addr", os.Getenv("VAULT_ADDR"), "Vault address")
    vaultToken      = flag.String("vault-token", os.Getenv("VAULT_TOKEN"), "Vault token")
    vaultPath       = flag.String("vault-path", "secret/data/minitoolstream/jwt", "Vault path for JWT keys")
    issuer          = flag.String("issuer", "minitoolstream", "JWT issuer")
    generateKeysCmd = flag.Bool("generate-keys", false, "Generate new RSA keys and save to Vault")
    showPublicKey   = flag.Bool("show-public-key", false, "Show public key from Vault")
)
```

### 3.7.3 Генерация и сохранение ключевой пары

Команда генерации ключей (`tools/jwt-gen/main.go:52-58`):

```go
// Обработка команды generate-keys
if *generateKeysCmd {
    if err := generateAndSaveKeys(ctx, vaultClient); err != nil {
        log.Fatalf("Failed to generate keys: %v", err)
    }
    fmt.Println("✓ RSA keys generated and saved to Vault successfully")
    return
}
```

Реализация (`tools/jwt-gen/main.go:80-87`):

```go
func generateAndSaveKeys(ctx context.Context, vaultClient *vault.Client) error {
    jwtManager, err := auth.NewJWTManagerFromVault(ctx, vaultClient, *vaultPath, *issuer)
    if err != nil {
        return err
    }

    return jwtManager.SaveKeysToVault(ctx, vaultClient)
}
```

Использование:

```bash
export VAULT_ADDR=http://localhost:8200
export VAULT_TOKEN=dev-root-token

# Генерация и сохранение ключевой пары
./jwt-gen -generate-keys
```

### 3.7.4 Просмотр публичного ключа

Команда просмотра публичного ключа (`tools/jwt-gen/main.go:60-67`):

```go
// Обработка команды show-public-key
if *showPublicKey {
    if err := showPublicKeyFromVault(ctx, vaultClient); err != nil {
        log.Fatalf("Failed to show public key: %v", err)
    }
    return
}
```

Реализация (`tools/jwt-gen/main.go:89-103`):

```go
func showPublicKeyFromVault(ctx context.Context, vaultClient *vault.Client) error {
    jwtManager, err := auth.NewJWTManagerFromVault(ctx, vaultClient, *vaultPath, *issuer)
    if err != nil {
        return err
    }

    publicKey, err := jwtManager.GetPublicKey()
    if err != nil {
        return err
    }

    fmt.Println("Public Key (PEM format):")
    fmt.Println(publicKey)
    return nil
}
```

Использование:

```bash
./jwt-gen -show-public-key
```

### 3.7.5 Генерация JWT токенов

Основная функция генерации токена (`tools/jwt-gen/main.go:105-148`):

```go
func generateToken(ctx context.Context, vaultClient *vault.Client) error {
    // Создание JWT manager из Vault
    jwtManager, err := auth.NewJWTManagerFromVault(ctx, vaultClient, *vaultPath, *issuer)
    if err != nil {
        return err
    }

    // Парсинг subjects
    allowedSubjects := []string{}
    if *subjects != "" {
        allowedSubjects = strings.Split(*subjects, ",")
        for i := range allowedSubjects {
            allowedSubjects[i] = strings.TrimSpace(allowedSubjects[i])
        }
    }

    // Парсинг permissions
    perms := []string{}
    if *permissions != "" {
        perms = strings.Split(*permissions, ",")
        for i := range perms {
            perms[i] = strings.TrimSpace(perms[i])
        }
    }

    // Генерация токена
    token, err := jwtManager.GenerateToken(*clientID, allowedSubjects, perms, *duration)
    if err != nil {
        return err
    }

    // Вывод информации о токене
    fmt.Printf("JWT Token generated successfully:\n\n")
    fmt.Printf("Client ID:        %s\n", *clientID)
    fmt.Printf("Allowed Subjects: %v\n", allowedSubjects)
    fmt.Printf("Permissions:      %v\n", perms)
    fmt.Printf("Valid For:        %v\n", *duration)
    fmt.Printf("Issuer:           %s\n\n", *issuer)
    fmt.Printf("Token:\n%s\n\n", token)
    fmt.Printf("Use this token in your client by setting the Authorization header:\n")
    fmt.Printf("Authorization: Bearer %s\n", token)

    return nil
}
```

### 3.7.6 Примеры использования

**Генерация токена с полными правами:**

```bash
./jwt-gen \
  -client="service-A" \
  -subjects="*" \
  -permissions="publish,subscribe,fetch" \
  -duration=720h
```

**Генерация токена с ограниченными правами:**

```bash
# Только publish в subjects "images.*"
./jwt-gen \
  -client="image-uploader" \
  -subjects="images.*" \
  -permissions="publish" \
  -duration=168h

# Только subscribe/fetch для "logs.*" и "metrics.*"
./jwt-gen \
  -client="log-processor" \
  -subjects="logs.*,metrics.*" \
  -permissions="subscribe,fetch" \
  -duration=168h
```

**Генерация токена для конкретного subject:**

```bash
./jwt-gen \
  -client="user-notification-service" \
  -subjects="notifications.user.email" \
  -permissions="publish" \
  -duration=24h
```

### 3.7.7 Интеграция с CI/CD

Утилита может быть интегрирована в CI/CD pipeline для автоматической генерации токенов:

```yaml
# GitHub Actions example
- name: Generate JWT Token
  env:
    VAULT_ADDR: ${{ secrets.VAULT_ADDR }}
    VAULT_TOKEN: ${{ secrets.VAULT_TOKEN }}
  run: |
    JWT_TOKEN=$(./jwt-gen \
      -client="${SERVICE_NAME}" \
      -subjects="${ALLOWED_SUBJECTS}" \
      -permissions="publish,subscribe,fetch" \
      -duration=168h | grep "Token:" -A 1 | tail -n 1)
    echo "::add-mask::$JWT_TOKEN"
    echo "JWT_TOKEN=$JWT_TOKEN" >> $GITHUB_ENV
```

---

## Заключение по главе 3

В данной главе представлена детальная реализация всех компонентов системы MiniToolStream с подробным анализом архитектурных решений, алгоритмов и технических подходов. Реализация демонстрирует применение современных практик разработки распределенных систем и решение сложных инженерных задач.

### 3.8.1 Ключевые достижения реализации

**1. Ingress Service - надежный прием сообщений**

Реализация Ingress Service демонстрирует решение фундаментальной проблемы координации операций в распределенных системах без поддержки распределенных транзакций. Критически важным является корректный порядок операций: сначала выделение sequence number, затем загрузка payload в MinIO, и только после этого - вставка метаданных в Tarantool. Такая последовательность гарантирует отсутствие race conditions при чтении сообщений подписчиками.

Дополнительно реализованы механизмы graceful degradation: при сбоях на любом этапе система остается в консистентном состоянии, а orphaned objects автоматически удаляются через TTL политики.

**2. Egress Service - гибкая доставка с гарантиями**

Egress Service предоставляет два complementary подхода к получению сообщений: push-модель через Subscribe для реактивных систем с минимальными задержками, и pull-модель через Fetch для систем с batch-обработкой. Реализация At-Least-Once delivery semantics через явный ACK обеспечивает надежность доставки критически важных данных при сбоях consumer'ов.

Важно отметить реализацию durable subscriptions с сохранением позиции чтения в Tarantool, что позволяет consumer'ам безопасно перезапускаться без потери данных.

**3. JWT Security Layer - многоуровневая защита**

Система безопасности построена на индустриальных стандартах (JWT с RSA-256) и предоставляет гранулярный контроль доступа через систему permissions и wildcard patterns для subjects. Интеграция с HashiCorp Vault обеспечивает централизованное управление криптографическими ключами и их безопасную ротацию.

Реализация условной аутентификации позволяет гибко настраивать требования безопасности в зависимости от окружения (development vs production), что упрощает разработку и тестирование.

**4. Гибридное хранилище - оптимальное разделение данных**

Архитектурное решение о разделении метаданных (Tarantool) и payload (MinIO) обеспечивает оптимальный баланс между производительностью и стоимостью хранения. Tarantool с in-memory индексами предоставляет микросекундные latencies для операций с метаданными, в то время как MinIO обеспечивает экономичное хранение больших объемов бинарных данных.

**5. Клиентская библиотека - developer experience**

Применение Builder Pattern и автоматическая инъекция JWT токенов через gRPC interceptors значительно упрощают интеграцию с системой. Разработчики могут сосредоточиться на бизнес-логике, не беспокоясь о деталях аутентификации и конфигурирования транспорта.

**6. Операционные инструменты - управление в production**

Утилита jwt-gen демонстрирует важность операционных инструментов для production систем. Простой command-line интерфейс для управления ключами и генерации токенов значительно снижает порог входа для DevOps инженеров.

### 3.8.2 Технологический стек и обоснование выбора

- **Go (Golang)**: Выбор языка Go обусловлен его превосходной поддержкой concurrency через goroutines, быстрой компиляцией и отличной производительностью для систем обработки данных
- **gRPC**: Использование gRPC обеспечивает эффективную бинарную сериализацию и нативную поддержку streaming
- **Tarantool**: In-memory СУБД с Lua stored procedures предоставляет субмиллисекундные latencies для metadata операций
- **MinIO**: S3-совместимое объектное хранилище обеспечивает масштабируемое и экономичное хранение payload
- **HashiCorp Vault**: Индустриальный стандарт для secrets management с поддержкой динамических credentials
- **JWT с RSA-256**: Асимметричная криптография позволяет распределенную валидацию токенов без shared secrets

### 3.8.3 Соответствие принципам проектирования

Вся реализация последовательно придерживается следующих принципов:

- **Clean Architecture**: Четкое разделение на domain, use case, repository и infrastructure слои
- **SOLID принципы**: Особенно Single Responsibility и Dependency Inversion
- **12-Factor App**: Конфигурация через environment variables, stateless processes, logs as event streams
- **Fail-Fast**: Ранняя валидация и четкие error messages
- **Defense in Depth**: Многоуровневая система безопасности от network до application layer

Все компоненты спроектированы с учетом production requirements: observability через структурированное логирование, graceful shutdown для zero-downtime deployments, и comprehensive error handling для resilience.

Представленная реализация создает прочную основу для дальнейшего развития системы и демонстрирует применение теоретических концепций распределенных систем на практике.
